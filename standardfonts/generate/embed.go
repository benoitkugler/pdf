package type1

import (
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"strings"

	"github.com/benoitkugler/pdf/fonts/simpleencodings"
)

// dumpFontDescriptor creates a go source file containing
// the description of the fonts `fs`
// WinAnsi is used instead of Standard because more western
// usual characters are supported
func dumpFontDescriptor(fs []Font) error {
	var code strings.Builder
	code.WriteString("package standardfonts\n")
	code.WriteString("// Code generated by standardfonts/generate. DO NOT EDIT\n\n")

	var sumupMap, winAnsiMap strings.Builder

	sumupMap.WriteString("// Fonts is a convenient mapping from a font name to its descriptor.\n")
	sumupMap.WriteString("var Fonts = map[string]Metrics{\n")

	winAnsiMap.WriteString("var winAnsiMetricsMap = map[string]winAnsiMetrics{\n")

	for _, f := range fs {
		fontDesc := f.FontDescriptor()
		firstChar, widths := f.Widths()
		goFontName := strings.ReplaceAll(string(fontDesc.FontName), "-", "_")
		if fontDesc.FontName == "ZapfDingbats" || fontDesc.FontName == "Symbol" {
		} else {
			firstChar, widths := f.WidthsWithEncoding(simpleencodings.WinAnsi.Names)
			winAnsiMap.WriteString(fmt.Sprintf("	%q: {\nFirstChar: %v,\n Widths:%#v,\n},\n", string(fontDesc.FontName), firstChar, widths))
		}
		code.WriteString("var " + goFontName + " = Metrics{\n")
		code.WriteString(fmt.Sprintf("Descriptor: %#v,\n", fontDesc))
		code.WriteString(fmt.Sprintf("FirstChar: %#v,\n", firstChar))
		code.WriteString(fmt.Sprintf("Widths: %#v,\n", widths))
		code.WriteString("}\n")

		sumupMap.WriteString(fmt.Sprintf(" %q: %s,\n", string(fontDesc.FontName), goFontName))
	}
	sumupMap.WriteString("}")
	winAnsiMap.WriteString("}")

	code.WriteString("\n" + sumupMap.String())
	code.WriteString("\n" + winAnsiMap.String())

	filename := "../fonts.go"
	err := ioutil.WriteFile(filename, []byte(code.String()), os.ModePerm)
	if err != nil {
		return err
	}

	err = exec.Command("goimports", "-w", filename).Run()
	return err
}
