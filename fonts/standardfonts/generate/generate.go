// Tool to generate the metrics for the standard Adobe Type1 fonts.
package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"sort"
	"strings"

	"github.com/benoitkugler/pdf/fonts/standardfonts"
	"github.com/benoitkugler/pdf/model"
	"github.com/benoitkugler/textlayout/fonts/type1"
)

// only widths
func simplifiedMetrics(f type1.AFMFont) map[string]int {
	out := make(map[string]int, len(f.CharMetrics))
	for name, m := range f.CharMetrics {
		out[name] = m.Width
	}
	return out
}

// Metrics returns the essential information from the font.
func metrics(f type1.AFMFont) standardfonts.Metrics {
	return standardfonts.Metrics{
		Descriptor:  fontDescriptor(f),
		CharsWidths: simplifiedMetrics(f),
		Builtin:     f.CharCodeToCharName,
		KernPairs:   f.KernPairs,
	}
}

type Fl = model.Fl

// widthsStats collect the mean and the maximum values
// of the glyphs width
func widthsStats(f type1.AFMFont) (mean, max Fl) {
	for _, c := range f.CharMetrics {
		w := Fl(c.Width)
		if w > max {
			max = w
		}
		mean += w
	}
	mean /= Fl(len(f.CharMetrics))
	return mean, max
}

// synthetize a fontDescriptor from various
// font metrics.
func fontDescriptor(f type1.AFMFont) model.FontDescriptor {
	if f.CapHeight == 0 {
		f.CapHeight = f.Ascender
	}
	isSymbolic := f.FontName == "Symbol" || f.FontName == "ZapfDingbats"

	flag := model.Nonsymbolic
	if isSymbolic {
		flag = model.Symbolic
	}

	if f.IsFixedPitch {
		flag |= model.FixedPitch
	}
	if f.ItalicAngle != 0 {
		flag |= model.Italic
	}
	if f.StdVw == 0 {
		isBold := f.Weight == "bold" || f.Weight == "black"
		if isBold {
			f.StdVw = 120
		} else {
			f.StdVw = 80
		}
	}

	out := model.FontDescriptor{
		FontName:    model.ObjName(f.FontName),
		FontFamily:  f.FamilyName,
		Flags:       flag,
		FontBBox:    model.Rectangle{Llx: Fl(f.Llx), Lly: Fl(f.Lly), Urx: Fl(f.Urx), Ury: Fl(f.Ury)},
		ItalicAngle: Fl(f.ItalicAngle),
		Ascent:      Fl(f.Ascender),
		Descent:     Fl(f.Descender),
		Leading:     0, // unknown
		CapHeight:   Fl(f.CapHeight),
		XHeight:     Fl(f.XHeight),
		StemV:       Fl(f.StdVw),
		StemH:       Fl(f.StdHw),
	}

	// use its width as missing width
	if notdef, ok := f.CharMetrics[type1.Notdef]; ok {
		out.MissingWidth = notdef.Width
	}

	out.AvgWidth, out.MaxWidth = widthsStats(f)

	out.CharSet = f.CharSet()

	return out
}

func sortedKeys(m map[string][]type1.KernPair) []string {
	var keys []string
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

// dumpFontDescriptor creates a go source file containing
// the description of the fonts `fs`
func dumpFontDescriptor(fs []type1.AFMFont) error {
	var code strings.Builder
	code.WriteString("package standardfonts\n")
	code.WriteString("// Code generated by standardfonts/generate. DO NOT EDIT\n\n")

	var sumupMap strings.Builder

	sumupMap.WriteString("// Fonts is a convenient mapping from a font name to its descriptor.\n")
	sumupMap.WriteString("var Fonts = map[string]Metrics{\n")

	for _, f := range fs {
		metrics := metrics(f)
		goFontName := strings.ReplaceAll(f.FontName, "-", "_")
		code.WriteString("var " + goFontName + " = Metrics{\n")
		code.WriteString(fmt.Sprintf("Descriptor: %#v,\n", metrics.Descriptor))
		code.WriteString(fmt.Sprintf("Builtin: %#v,\n", metrics.Builtin))
		code.WriteString(fmt.Sprintf("// %d characters\n", len(metrics.CharsWidths)))
		code.WriteString(fmt.Sprintf("CharsWidths: %#v,\n", metrics.CharsWidths))
		code.WriteString(fmt.Sprintf("// %d characters\n", len(metrics.KernPairs)))

		s := ""
		keys := sortedKeys(metrics.KernPairs)
		for _, name := range keys {
			list := metrics.KernPairs[name]
			s += fmt.Sprintf("%q: %#v,\n", name, list)
		}
		s = strings.ReplaceAll(s, "[]type1.KernPair", "")
		s = strings.ReplaceAll(s, "type1.KernPair", "")

		code.WriteString("KernPairs: map[string][]type1.KernPair{\n")
		code.WriteString(s)
		code.WriteString("},\n")
		code.WriteString("}\n")

		sumupMap.WriteString(fmt.Sprintf(" %q: %s,\n", f.FontName, goFontName))
	}
	sumupMap.WriteString("}")

	code.WriteString("\n" + sumupMap.String())

	filename := "fonts.go"
	err := ioutil.WriteFile(filename, []byte(code.String()), os.ModePerm)
	if err != nil {
		return err
	}

	err = exec.Command("goimports", "-w", filename).Run()
	return err
}

func main() {
	files, err := ioutil.ReadDir("generate/afms")
	if err != nil {
		log.Fatal(err)
	}
	var fonts []type1.AFMFont
	for _, info := range files {
		if !strings.HasSuffix(info.Name(), ".afm") {
			continue // licence file
		}

		f, err := os.Open("generate/afms/" + info.Name())
		if err != nil {
			log.Fatal(err)
		}

		font, err := type1.ParseAFMFile(f)
		if err != nil {
			log.Fatalf("can't parse file %s : %s", info.Name(), err)
		}
		f.Close()

		fonts = append(fonts, font)
	}
	if err = dumpFontDescriptor(fonts); err != nil {
		log.Fatal(err)
	}
}
